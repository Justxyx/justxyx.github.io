---
title: Effective C++ p3 资源管理
author: xyx
date: 2022-5-11 20:33:00 +0800
categories: [C++, effective]
tags: 
math: true
---

## 13. 以对象管理资源

申请一块动态内存后，可能会发生泄露，其原因无非以下几点：

- 忘记delete

- 有delete，但是提前returnle

- 抛出异常了

所以，最好的解决方法就是，使用对象来管理资源，包括下列两个关键性的想法：

1. 获得资源后立刻放进管理对象

2. 管理对象运用的对象确保资源会被释放。**如条款8中提到的 析构函数抛出异常**

简单说一下两类智能指针，'auto_ptr` 和 `shared_ptr`.

1. `auto_ptr`现在基本不用了，主要原因是其在拷贝构造与拷贝赋值中，会将原始的对象的指针置为NULL，拷贝后的对象获得这唯一指针。这设计...enm...。确实保证了任何时候只有一根指针。

2. `shared_ptr`,聪明多了，会有计数器。所以推荐使用`shred_ptr`.

3. 最重要的一个问题，上述两智能指针都未对数组指针有优化，其`delete p`动作，而不是`delete p[]`动作，关键是**编译器还不报错**。这个问题的解释为：vector 和 string 基本可以替代数组的大部分大部分要求了，如果你非要智能指针来管理数组指针，推荐使用别的。

