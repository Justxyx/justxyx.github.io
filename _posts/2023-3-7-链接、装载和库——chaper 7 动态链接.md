---
title: 链接、装载和库——chaper 7 动态链接
author: xyx
date: 2023-3-7 13:33:00 +0800
categories: [justxyx, system-programming]
tags:
math: true
---



## 1. 概览

1. 为什么需要动态链接？
    - 静态链接方式对计算机内存和磁盘空间的浪费非常严重。
    - 程序的开发与发布， 一旦程序的一个小部分做出更改， 那么则需要对整个程序进行重新下载。

2. 静态链接的基本思想
    把程序的模块互相分割开来，不再将他们静态的链接在一起。 **把链接的过程推迟到运行时进行**， 即为动态链接。

3. 一个动态链接的例子。
    Program1.o 和 Program2.o 都依赖于Lib.o, 当运行Program1 时， 系统加载Program1和Lib.o及所有依赖。 当运行Program2时， 则不需要重新加载Lib.o ，因为内存中已经存在了一份Lib.o 的副本， 系统要做的仅仅是把Program2.o 和 Lib.o 链接起来。

4. 动态链接优势在哪？
    - 节省内存，减少物理页的换入换出。
    - 不同进程的数据和指令访问都集中在了同一个共享模块上。
    - 系统升级时， 理论上只需要简单的把旧文件用新文件覆盖掉。无需把所有的文件都重新连接一次。 程序下一次运行的时候， 新版本的目标文件湖北自动装载到内存中并连接起来。

5. 所有静态链接和动态链接的本区区别在哪？
    - 静态链接：编译时链接， 装载时重定位。
    - 动态链接： 装载时链接。

6. 动态链接的过程
    静态链接由ld链接器连接。
    动态链接由**动态链接器**链接。 装载时链接。

7. 几点备注：
    - 假如foo()是一个定义在其他模块中的函数， 在静态链接中，链接器会按照静态链接的规则，将main.o 中的foo() 地址引用重定位。在动态链接中， 链接器会将这个符号引用标记为一个动态链接符号。
    - 链接器如何知道是动态符号还是静态符号？ 链接器在解析符号的时候可以知道。

8. 动态链接时的空间分布
    进程的虚拟空间中：目标文件、动态库、动态连接器。
    **系统在开始运行main文件前，会先把控制权交给动态链接器，由它完成所有动态链接工作后再把控制权还给main,然后开始执行**。
    共享对象的最终装载地址在编译时期是不确定的，在装载时，装载起根据地址空间的空闲情况，分配一块足够大小的虚拟内存。

## 2. 地址代码无关

[地址代码无关]("https://www.cnblogs.com/chendeqiang/p/14312122.html")

这里只备注一点：若lib.so中定义了一个全局变量G， 进程A和进程B都是用了lib.o ， 那么进程A改变全局变量G的值的时候， 进程B中的G会受到影响吗？

**不会， 每个进程都有自己独立的数据段备份**。

## 3. 延迟绑定

这个没什么好说的， 动态链接比静态链接效率要低一点点， 解决方案为延迟绑定， 通俗的说就是**用到的时候才绑定**。



