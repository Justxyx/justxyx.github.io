---
title: p6 内存管理，基于linux0.11
author: xyx
date: 2022-1-26 20:33:00 +0800
categories: [C++, linux-os]
tags: 
math: true
---


## 1. 程序分段


### 1.1 为什么要分段？

- 编译重定位

- 载入重定位

- 运行重定位


> cpu本质上就是取指执行。 问题的核心， 指令地址在哪？

### 2.2 分段

引入段表  每个进程的pcb中，都有一根指向LDT表的指针。

**LDT 表， 包含 段号，基地址，长度**

有了段号，有了基地址，通过MMU就可以找到实际的物理地址。

## 2. 内存分区

思考一个问题，按道理来说，程序有了分段，就可以满足系统的基本要求，那为什么又要引出分区的概念呢？

### 2.1 内存分配算法

- 首先适配

- 最佳适配 

- 最差适配

**引出内存碎片的问题**

### 2.2 分页机制

**页表内容： 页号，页框号，保护**

指令 “ mov [0x2240], %eax" 解读：

1. 页框大小为4KB
2. 0x2240 表示这个地址在进程段的第二个页面上（页号）
3. 根据页号找到框号， 加上**剩余的地址** ， 就是实际的物理地址。

### 2.3 为什么引入多级页表 

每个进程都需要有一个全尺寸页表， 页表太大浪费空间。

1. 方法一

去掉不用的页号。 不太行， 不能随机查找，每次访问地址，时间开销太大。

2. 多级页表

引出多级页表以及快表 

**块表**： TLB，多级页表的映射缓存。


## 3. 段页内存管理

程序员角度： 我想对程序用段，我希望内存可以分段管理。

内存角度： 我希望分页，分页产生的内存碎片较少。

## 3.2 段页结合 虚拟内存 

1. 将虚拟内存中分割出一些分区，将程序的各个段放入。 分割算法可以用前面提到的（最佳适配，最差适配）等算法。


2. 建立段表

**程序段 与虚拟内存之间的映射关系**

 |段号|基地址|长度|保护|
 |-|-|-|-|
 |0|1000|300|R|

3. 将虚拟内存分割成虚拟页

根据基地址分割，跟段号是没什么关系的。 

4. 建立页表，虚拟页与物理页映射

这章不太明白可以看看p172，讲的很清楚。




