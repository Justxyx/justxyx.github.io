---
title: Abstract,Static,Final三个关键字
author: xyx
date: 2021-5-18 20:33:00 +0800
categories: [justxyx, computer-system-structure]
tags: 
math: true

---

## Abstract 
1. 抽象方法
   * 抽象方法没有主体，我们不能直接调用抽象方法
   * 抽象方法不能用private修饰，因为抽象方法必须被子类实现。
   * 抽象方法也不能用abstract修饰。 如果用abstract修饰，那么可以直接通过类名来调用，这与上述描述不符合。
  
2. 抽象类
   * 用abstract关键字来表达的类，其表达形式为：（public）abstract class 类名{}

   * 抽象类不能被实例化，也就是说我们没法直接new 一个抽象类。抽象类本身就代表了一个类型，无法确定为一个具体的对象，所以不能实例化就合乎情理了，只能有它的继承类实例化。

   * 抽象类虽然不能被实例化，但有自己的构造方法（这个后面再讨论）

   * 抽象类与接口（interface）有很大的不同之处，接口中不能有实例方法去实现业务逻辑，而抽象类中可以有实例方法，并实现业务逻辑，比如我们可以在抽象类中创建和销毁一个线程池。

   * 抽象类不能使用final关键字修饰，因为final修饰的类是无法被继承，而对于抽象类来说就是需要通过继承去实现抽象方法，这又会产生矛盾。（后面将写一篇关于finally的文章详细讨论）
3. 总结
   * 如果一个类中至少有一个抽象方法，那么这个类一定是抽象类，但反之则不然。也就是说一个抽象类中可以没有抽象方法。这样做的目的是为了此类不能被实例化。
   * 如果一个类继承了一个抽象类，那么它必须全部覆写抽象类中的抽象方法，当然也可以不全部覆写，如果不覆写全部抽象方法则这个子类也必须是抽象类（这样做就无意义了）
   * 抽象类是有构造方法的 **（重点)**
        * 和普通的继承类一样，在new 一个子类对象时会优先调用父类的构造器初始化，然后再调用子类的构造器。
        * 关于继承问题，this super 等关键字会在后期的博客中写出。
  
## static
1. 静态方法
   * 静态方法不依赖任何对象就可以直接访问。
   * **静态方法不能调用任何非静态变量** p227
   * **静态方法不能调用非静态方法**
2. 静态变量
   被所有的对象所共享。
3. static 代码块
   起到初始化的作用
   ~~~java
   static {
       ```
   }
   ~~~
## final
1. 静态的final是常数
   ~~~java
   public static final double PI = 3.1415
    <!-- PI 要全部大写 -->
   ~~~
2. 非静态的final变量
   不可改变
3. final 的方法
   final 的方法不可被覆盖。
4. final 的类
   final 的类不可被继承。